\section{Background and Related Work}

\subsection{Transactional Memory}
The concept of a transaction, or a group of operations, allows a programmer to reason about a transaction as the smallest unit of work. The concept developed first in database theory, then evolved with the development of hardware transactional memory in 1986, and later in 1995 emerged in software transactional memory (STM). Transactional memory\cite{harristm}\cite{herlihytm} simplifies reasoning about parallel executions on shared memory by restricting how threads of execution can interact. Transactions are \emph{serializable}, which means that one can find an ordering of committed transactions that satisfies the observed history of the execution: operations within one transaction are never interleaved with operations in another transaction. Transactions are also \emph{atomic}: if a transaction commits, all changes made by the transaction are instantly visible to other threads; if a transaction aborts, no other thread sees any of the changes made by the transaction. Finally, transactions are \emph{linearizable}\cite{linearizability}: all transactions performed at a later clock time than a committed transaction observe the changes made by the committed transaction. This allows programmers to easily determine the order and effects of transactions.

Transactional memory systems enforce transactional guarantees in the following way: first, during a transaction's execution, the system tracks any intended changes to be made during the transaction in the transaction's \emph{write set} and any state observed during the transaction in the transaction's \emph{read set}. When the transaction attempts to commit, the system checks whether the observed values in the read set are still valid. If so, the system performs the changes in the transaction's write set and the transaction is marked committed. Else the transaction aborts and the system ensures that the transaction leaves no visible effects.

Transactional memory can be implemented in both hardware and software. Hardware transactional memory (HTM) naturally outperforms software TMs, but a purely hardware TM has capacity restraints and are not truly composable\cite{htm}. The STO system\cite{sto} is one of several developed software transactional memory (STM) systems. TL2\cite{tl2} and LarkTM\cite{larktm} are highly-optimized word-STMs that track memory words touched during a transaction. SwissTM\cite{swisstm} is also a word-STM, but increases performance by tracking memory in 4-word groups, resulting in less overhead than tracking individual memory words. There has also been significant research in non-transactional APIs (open nesting\cite{opennesting}, elastic transactions\cite{elastic}, transactional collection classes\cite{tcc}, early release\cite{earlyrelease}, SpecTM\cite{spectm}); these allow for programmers to reduce false conflicts or bookkeeping costs, but also require programmers to be experts in the system. This complicates, rather than simplifies, concurrent programming. There have also been object-based STMs which track objects instead of memory words, but incur extra cost by shadow copying any objects written to within the transaction. STO is one of several STM systems that use abstraction to improve TM performance\cite{boost}\cite{optboost}\cite{autolock}\cite{predication}. These systems expose a transactional API to programmers in the form of concurrent data structures; these data structures are written on top of an STM. However, these systems build their data structures on top of traditional word-STMs, whereas STO builds data structures on top of an abstract STM which tracks abstract items defined by each data structure. This lets STO to improve performance beyond that of previous systems. Many STMs, including STO, are now looking to improve performance by integrating STM with HTM.

\subsection{Abstract Data Types in STM}
Our work focuses on data types and how they perform within transactional settings. We now take a closer look at other abstract STM systems that expose an API in the form of transactional data structures that allow programmers to work with transactions.

\subsubsection{Boosting}
\subsubsection{Automated Locking}
\subsubsection{Predication}
\subsubsection{Transactional Data Structures Library}
\subsubsection{Commutativity in Transactional Data Structures}
Weihl
Galois
Schwartz and Spector
Badrinath and Ramamritham
Korth
CRDTs/database community

STO
Techniques used in STO: locking, optimistic verification, direct updates, deferred updates

