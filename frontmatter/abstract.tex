STO is a software transactional memory system that both outperforms previous such systems and simplifies the challenging, yet increasingly critical, task of parallel programming by allowing programmers to reason about concurrent operations through transactions---atomic groups of operations---instead of single operations.  
However, STO's performance still falls short of that of the fastest concurrent programming techniques. This work aims to make STO as fast as these concurrent programming techniques, and, when this appears impossible, to characterize precisely why. 
We implement and benchmark the most performant concurrent programming algorithms for abstract datatypes within STO's transactional framework. Our results indicate that certain concurrent datatype algorithms lose their scalability and performance in a transactional setting, while other algorithms successfully support transactions without incurring a crippling performance loss. We claim that this discrepancy arises because various concurrent algorithms have different levels of dependency on operation commutativity, and suffer different amounts of commutativity loss in a transactional setting. To support this claim, we implement a concurrent datatype whose performance is crippled in a transactional setting with an alternative interface that allows for greater operation commutativity: with this alternative interface, the concurrent datatype retains its performance and scalability in a transactional setting.
We conclude that evaluating a datatype's dependency on operation commutativity and the commutativity of operations in a transaction setting provides a method to determine whether a highly-concurrent, non-transactional data structure can be integrated with STO while still achieving high scalability and performance.
