STO is a software transactional memory system that both outperforms previous such systems and simplifies the challenging, yet increasingly critical, task of parallel programming by allowing programmers to reason about concurrent operations through transactions---atomic groups of operations---instead of single operations.  
However, STO's performance still falls short of that of the fastest concurrent programming techniques. This work discusses how to make STO as fast as these non-transactional, concurrent programming techniques, and, when this appears impossible, to characterize precisely why. 
We implement and benchmark the most performant concurrent programming algorithms for abstract datatypes within STO's transactional framework, and determine that certain concurrent datatype algorithms gain performance from techniques that appear to be incompatible for use in transactions.
However, other algorithms can successfully support transactional guarantees without incurring a crippling performance loss. We claim that this discrepancy arises due to the concurrent algorithms' differing levels of dependency on operation commutativity, and dfferent amounts of commutativity loss when the algorithms are moved into a transactional setting. To support this claim, we implement concurrent datatypes with an alternative operation interface that allows for greater amounts of commutativity in a transactional setting than did the original interface. Our results indicate that an alternative interface with greater commutativity allows the concurrent datatype to retain its performance and scalability in a transactional setting.
