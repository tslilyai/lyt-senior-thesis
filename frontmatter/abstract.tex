STO is a software transactional memory system that simplifies the challenging, yet increasingly critical, task of parallel programming by allowing programmers to reason about concurrent operations in terms of transactions---atomic groups of operations---instead of single operations.  
STO outperforms previous software transactional memory systems, but its performance still falls short of that of the fastest concurrent programming techniques. This work aims to make STO as fast as these techniques, and, when this appears impossible, to characterize precisely why. 
We implement and benchmark the most performant concurrent programming algorithms for abstract datatypes within STO's transactional framework. Our results indicate that certain concurrent datatype algorithms lose their scalability and performance in a transactional setting, while other algorithms successfully support transactions without incurring a crippling performance loss. We claim that this discrepancy arises because various concurrent algorithms have different levels of dependency on operation commutativity, and suffer different amounts of commutativity loss in a transactional setting. To support this claim, we pose an alternative operation interace that allows for greater operation commutativity, and, with this interface, re-implement a concurrent datatype whose performance is crippled in a transactional setting. The concurrent datatype with the alternative interface retains its performance and scalability in a transactional setting.
We conclude that a datatype's dependency on operation commutativity, and the loss of commutativity in a transaction setting, determine whether a highly-concurrent, non-transactional data structure can be integrated with STO while still achieving high scalability and performance.
