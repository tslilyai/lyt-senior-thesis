STO is a software transactional memory system that both outperforms previous such systems and simplifies the challenging, yet increasingly critical, task of parallel programming by allowing programmers to reason about concurrent operations through transactions---atomic groups of operations---instead of single operations.  
However, STO's performance still falls short of that of the fastest concurrent programming techniques. This work discusses how to make STO as fast as these non-transactional, concurrent programming techniques, and, when this appears impossible, to characterize precisely why. 
We implement and benchmark the most performant concurrent programming algorithms for abstract datatypes within STO's transactional framework, and determine that certain concurrent datatype algorithms gain performance from techniques that appear to be incompatible for use in transactions.
However, other algorithms can successfully support transactional guarantees without incurring a crippling performance loss. We claim that this discrepancy arises due to the concurrent algorithms' differing levels of dependency on operation commutativity. To support this claim, we implement concurrent datatypes in an alternative transactional interface with greater operation commutativity. Our results indicate that an alternative transactional interface with greater commutativity allows a concurrent datatype to greatly outperform its strongly transactional counterpart.
