STO is a software transactional memory system that both outperforms previous such systems and simplifies the challenging, yet increasingly critical, task of parallel programming by allowing programmers to reason about concurrent operations through transactions---atomic groups of operations---instead of single operations.  
However, STO's performance still falls short of that of the fastest concurrent programming techniques. This work discusses how to make STO as fast as these non-transactional, concurrent programming techniques, and, when this appears impossible, to characterize precisely why. 
We implement and benchmark the most performant concurrent programming algorithms for abstract datatypes within STO's transactional framework. Our results indicate that certain concurrent datatype algorithms' scalability and performance are negated in a transactional setting.
However, other algorithms can successfully support transactional guarantees without incurring a crippling performance loss. We claim that this discrepancy arises due to the concurrent algorithms' differing levels of dependency on operation commutativity, and different amounts of commutativity loss when the algorithms are moved into a transactional setting. To support this claim, we modify the interface of a concurrent datatype that is crippled in a transactional setting; this alternative interface allows for greater amounts of commutativity in a transactional setting than did the original interface. Our results indicate that an alternative interface with greater commutativity allows the concurrent datatype to retain its performance and scalability in a transactional setting.
