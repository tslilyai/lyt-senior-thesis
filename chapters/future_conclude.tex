\chapter{Future Work and Conclusion}

\section{Future Work}
One extension that would further increase performance is to specialize our data structures for singleton transactions. As we saw in Chapter~\ref{commutativity}, the commutativity of singleton transaction allows for optimizations that are impossible when a transaction contains more than one operation. However, singleton transactions would need to be carefully handled for the case in which they interleave with multi-operation transactions. 

We would also like to further test the idea that we can increase the performance of transactional STO data structures by incorporating highly-concurrent data structures with STO only if the data structures' algorithms do not need to be heavily modified to support transactions (i.e., the algorithms do not heavily depend on operation commutativity).
As noted in Chapter~\ref{hashmap}, we can also further optimize our transactional cuckoo hashmap by eliminating element allocations, which are unavoidable in the chaining hashmap. Correctly doing so, however, remains an open challenge.

For algorithms in which transactional modifications cripple their optimizations (such as the FIFO queue or priority queue), alternative weaker transactional specifications, such as the one we proposed for the queue, can be explored. These specifications can be tuned to provide some useful guarantees beyond that of a simple concurrent data structure, yet still allow for concurrent algorithm optimizations to increase performance.

\section{Conclusion}
This thesis argues that retaining the performance benefits of highly-concurrent data structure algorithms within a transactional framework such as STO is contingent upon the amount of independence between the synchronization strategy used by the highly-concurrent algorithm and the transactional bookkeeping that must be added to support transactions.

Our work with the flat combining queues demonstrates that, while there is a large performance gap between our naively-concurrent transactional queues and the best-performing non-transactional, concurrent queue (the flat combining queue), the flat combining queue suffers crippling performance loss when moved into STO. We claim that this is because the flat combining technique relies on operation commutativity that is disallowed in a transactional framework, and that the modifications to flat combining required to support transactions reduce the effectiveness of the flat combining technique. Through exploration of an alternative transactional queue specification that allows greater operation commutativity, we provide evidence that the effectiveness of the flat combining technique is dependent on the number of valid histories---a measure directly affected by the transactional specification.

As an example of the opposite phenomenon, in which the concurrent algorithm retains its performance benefits, we look to cuckoo hashing algorithms. We demonstrate that certain beneficial properties of cuckoo hashmaps (such as good performance in a small hashmap with several values in each bucket) are present even in a transactional setting, and argue that this is because the cuckoo hashing synchronization algorithm can be implemented independently of the transactional bookkeeping to support transactions.

Our results provide a way to determine in advance whether a highly-concurrent, non-transactional data structure can be integrated with STO while still achieving scalability and performance greater than that of a simpler concurrent algorithm. With our results, we can better explain why and how different transactional algorithms often achieve either a surprisingly low or surprisingly high performance.
