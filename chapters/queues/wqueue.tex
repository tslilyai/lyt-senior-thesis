\section{The Weakly Transactional Queue} 

The Weakly Transactional Queue (WT-FCQueue) demonstrates how the transactional flat combining technique's performance depends upon the number of histories that the transactional specification deems invalid. This queue implements the weakly-transactional specification, which meets all the invariants of a \emph{concurrent} queue, but provides the following weakly transactional guarantees instead of the transactional ones listed earlier in Chapter~\ref{queue}:
\begin{itemize}
    \item Instead of the normal pops, the queue executes \emph{LazyPops} with the following specification:
        \begin{itemize}
            \item Any two pops within same the transaction do not need to pop consecutive values off the queue.
            \item A pop's return value cannot be accessed during the transaction. The pops are applied and their return values determined only at commit time (hence the name LazyPop).
        \end{itemize}
    \item A pop cannot remove a value pushed earlier in the same transaction (no \emph{read-my-writes}).
    \item The \emph{atomic} property thus becomes: a transaction with multiple pops and multiple pushes guarantees that either the operations will all occur or no operations will occur.
\end{itemize}

Given this specification, interleavings 1, 2, and 3 in Table~\ref{tab:interleavings} are allowable. This is because two pops in a transaction do not need to pop consecutive values off the queue and pop return values are hidden at execution time, which has the same effect as if a pop operation interface would return \texttt{void} during the transaction's execution. As we described earlier in Section~\ref{dep_cycles}, such pop operations commute with all operations; this allows all pops to be executed at commit time with any correct concurrent queue algorithm.

Interleaving 4 is prevented by installing all pushes in the same transaction together at commit time, and interleaving 5 is allowed because $T1$'s pop cannot see its earlier pushed value.

The queue under this specification retains all the fairness properties of a concurrent queue: no value remains in the queue forever, because values are still removed in the order in which they are added. Like Schwarz~\cite{schwarz}, we see uses for this transactional queue as a buffer between producer and consumer activities, in which the exact ordering of values in the buffer is unimportant.
The weakly-transactional specification differs from that of Schwarz, however, by preventing a pop from seeing a push within the same transaction, and by preventing access to the return value of a pop until after the transaction commits. This allows us to utilize the flat combining approach to its full potential: we do not need to generate additional flat combining calls during transaction execution because the queue does not need to be accessed until commit time.

\subsection{Algorithm}

We implement two weakly transactional queues, one that uses a naive synchronization algorithm (the WT-Queue), and one that uses flat combining (the WT-FCQueue). This allows us to determine if changes in performance are due to the changes in the transactional specification, or are instead caused by differences in synchronization algorithms.

\subsubsection{WT-Queue}
The WT-Queue uses the naive synchronization strategy from the T-QueueO and T-QueueP. The head version (for pops) or the tail version (for pushes) is locked prior to actually performing the push or pop at commit time. A call to pop or push at execution time does not require any access to the queue state, but merely returns a LazyPop when pop is called or adds an item to the \texttt{write\_list} when push is called.

\subsubsection{WT-FCQueue}
The WT-FCQueue uses the flat combining algorithm. We modify the non-transactional, flat combining technique as follows:
\begin{itemize}
    \item \emph{Pops}: 
    Executing a pop returns a LazyPop value. It does not generate a flat combining request or access the queue itself. At commit time, all LazyPops are instantiated with values: for each LazyPop, the thread makes a \texttt{<POP>} flat combining request. This request is completed using the vanilla, concurrent \texttt{<POP>} flat combining implementation, which simply pops an item off the queue.

    \item \emph{Pushes}: 
    Executing a push merely adds the value onto a \texttt{write\_list\_item} and does not access the queue. Pushes from the same transaction are installed together at commit time, using the \texttt{<PUSH, list>} flat combining implementation from the transactional flat combining queue that takes the entire list and pushes each value onto the queue.
\end{itemize}

\subsection{Evaluation and Results}

\begin{figure}[H]
    \centering
    \boxed{\includegraphics[width=\textwidth]{fcqueues/lpQ:RandSingleOps10000.png}}
    \caption{WT-Queue Performance, Multi-Thread Singletons Test}
    \label{fig:wtqs}
\end{figure}


We evaluate the weakly transactional flat-combining queue on the same benchmarks described in Section~\ref{q_microbenchmarks} to compare against the strongly-transactional flat-combining queue (T-FCQueue), the T-QueueP, and the NT-FCQueueWrapped. Selected results are shown in Figure~\ref{fig:wtqs}; full results are in Appendix~\ref{app:queues}. 

While the weakly-transaction, flat combining queue (WT-FCQueue) does not perform as well as its non-transactional counterpart, NT-FCQueue, the performance of the WT-FCQueue exceeds that of the T-QueueO, the T-QueueP, and the T-FCQueue, which all provide full-transactional guarantees. We see gains in performance over the T-QueueP up to 1.5$\times$ as the number of threads accessing the queue increases to 20; the WT-FCQueue begins to outperform the T-QueueP as the number of threads increases past 7. The WT-FCQueue outperforms the T-FCQueue starting at 4 threads and achieves performance up to about 5$\times$ by 20 threads.
 
The WT-FCQueue does not experience any aborts. This is due to the flat combining algorithm, which does not require that any locks be held in the weakly transactional setting in order to ensure correctness. A transaction can abort only if the result of a pop is accessed during the transaction's execution.
Because of the lack of aborts, the WT-FCQueue significantly outperforms the T-FCQueue; this demonstrates the effectiveness of the flat combining technique in the weakly transactional setting. 

We compare the WT-FCQueue against the WT-Queue to evaluate whether performance improves because we changed the queue algorithm, or whether performance improves because the weakly-transactional specification has fewer requirements than the strongly-transactional specification. The WT-Queue performs worse than all other queues because of its high abort rate (50--70\% as the number of threads increases, with 100\% of aborts occurring at commit time). This is caused by contention on the headversion and the tail version locks. While the actual pop function called during a transaction's execution is much simpler than in the T-QueueO or T-QueueP algorithms---it does not access the queue to check if the queue is empty---the installation procedure becomes more complicated; installing a pop requires instantiating all LazyPops, which more than doubles the number of cache misses of the T-QueueP. The WT-FCQueue incurs approximately 2$\times$ more cache misses than the NT-FCQueue, but is not crippled from LazyPop-caused cache misses because the flat combining algorithm optimizes for efficient cache usage. Unlike the WT-FCQueue, the WT-Queue holds a global lock during installation at commit time, aborting or delaying other transactions that attempt to commit. Thus, we see that the flat combining algorithm, and not the choice of transactional specification, is the source of the weakly transactional, flat combining queue's increased performance.

Our results show significant improvements in the performance of the flat combining algorithm when satisfying the weakly-transactional queue specification compared to its performance when satisfying a strongly-transactional one. This demonstrates that the commutativity of operations (specifically the pop operation), and therefore the number of invalid execution histories, directly affects the effectiveness of the flat combining algorithm. We argue that the modifications to provide strongly-transactional guarantees with our queue operation interface critically impair the performance of the flat combining algorithm, and that these modifications cannot be avoided. Thus, scalable performance of a flat combining queue with our queue interface is unlikely to be achievable in a strongly-transactional setting.
